{"version":3,"sources":["webpack://migration-data-model/webpack/universalModuleDefinition","webpack://migration-data-model/webpack/bootstrap","webpack://migration-data-model/./src/constants.js","webpack://migration-data-model/./src/formatErrors.js","webpack://migration-data-model/./src/index.js","webpack://migration-data-model/./src/models/Album.js","webpack://migration-data-model/./src/models/Photo.js","webpack://migration-data-model/./src/models/User.js","webpack://migration-data-model/./src/models/index.js","webpack://migration-data-model/./src/models/seedUser.js","webpack://migration-data-model/./src/models/sequelize.js","webpack://migration-data-model/./src/pubsub.js","webpack://migration-data-model/./src/resolvers/albums.js","webpack://migration-data-model/./src/resolvers/bin.js","webpack://migration-data-model/./src/resolvers/index.js","webpack://migration-data-model/./src/resolvers/photos.js","webpack://migration-data-model/./src/resolvers/users.js","webpack://migration-data-model/./src/schema/albums.js","webpack://migration-data-model/./src/schema/bin.js","webpack://migration-data-model/./src/schema/index.js","webpack://migration-data-model/./src/schema/photos.js","webpack://migration-data-model/./src/schema/users.js","webpack://migration-data-model/./src/services/TaskQueue.js","webpack://migration-data-model/./src/services/auth.js","webpack://migration-data-model/./src/services/batch.js","webpack://migration-data-model/./src/services/exif.js","webpack://migration-data-model/./src/services/file.js","webpack://migration-data-model/./src/services/permissions.js","webpack://migration-data-model/./src/services/processFile.js","webpack://migration-data-model/./src/services/resize.js","webpack://migration-data-model/./src/services/utils.js","webpack://migration-data-model/external \"apollo-server\"","webpack://migration-data-model/external \"apollo-server-express\"","webpack://migration-data-model/external \"bcrypt\"","webpack://migration-data-model/external \"body-parser\"","webpack://migration-data-model/external \"compression\"","webpack://migration-data-model/external \"cors\"","webpack://migration-data-model/external \"dotenv\"","webpack://migration-data-model/external \"exif\"","webpack://migration-data-model/external \"express\"","webpack://migration-data-model/external \"file-system\"","webpack://migration-data-model/external \"graphql-playground-middleware-express\"","webpack://migration-data-model/external \"graphql-subscriptions\"","webpack://migration-data-model/external \"http\"","webpack://migration-data-model/external \"image-size\"","webpack://migration-data-model/external \"jsonwebtoken\"","webpack://migration-data-model/external \"merge-graphql-schemas\"","webpack://migration-data-model/external \"mkdirp\"","webpack://migration-data-model/external \"path\"","webpack://migration-data-model/external \"progress-stream\"","webpack://migration-data-model/external \"rimraf\"","webpack://migration-data-model/external \"sequelize\"","webpack://migration-data-model/external \"sharp\""],"names":[],"mappings":"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;AACA;AACA,GAAG;AACH;AACA,UAAU,gDAAS;AACnB;AACA;AACA,GAAG;AACH;AACA,UAAU,gDAAS;AACnB;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;;AAGc,oEAAK,EAAC;;;;;;;;;;;;;AC3CrB;AAAA;AAAA;AAAA;AAAkC;AACE;;AAEpC,cAAc,kDAAS;AACvB;AACA,UAAU,gDAAS;AACnB;AACA;AACA,GAAG;AACH;AACA,UAAU,gDAAS;AACnB;AACA,GAAG;AACH;AACA,UAAU,gDAAS;AACnB;AACA,GAAG;AACH;AACA,UAAU,gDAAS;AACnB;AACA,GAAG;AACH,SAAS,gDAAS;AAClB,WAAW,gDAAS;AACpB;AACA,UAAU,gDAAS;AACnB;AACA,GAAG;AACH;AACA,UAAU,gDAAS;AACnB;AACA,GAAG;AACH,YAAY,gDAAS;AACrB,WAAW,gDAAS;AACpB,YAAY,gDAAS;AACrB,OAAO,gDAAS;AAChB,eAAe,gDAAS;AACxB,aAAa,gDAAS;AACtB;AACA,UAAU,gDAAS;AACnB;AACA;AACA,GAAG;AACH;AACA,UAAU,gDAAS;AACnB;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAEc,oEAAK,EAAC;;;;;;;;;;;;;AC/DrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACA;AACM;AACE;AACO;;AAE3C;;AAEA,6CAAM;;AAEN,OAAO,KAAK,GAAG,gDAAS;;AAExB,aAAa,kDAAS;AACtB;AACA,UAAU,gDAAS;AACnB;AACA;AACA,GAAG;AACH;AACA,UAAU,gDAAS;AACnB;AACA;AACA,GAAG;AACH;AACA,UAAU,gDAAS;AACnB;AACA;AACA,GAAG;AACH;AACA,UAAU,gDAAS;AACnB;AACA,GAAG;AACH;AACA,UAAU,gDAAS;AACnB;AACA;AACA,GAAG;AACH,WAAW,gDAAS;AACpB,CAAC;;AAED;AACA;A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;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;AC3EF;AAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACvBF;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEe,wEAAS,EAAC;;;;;;;;;;;;;AC7BzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+B;AACH;;AAErB;AACP;AACA;AACA,GAAG;;AAEH,sBAAsB,mDAAG;AACzB,KAAK,QAAQ,wBAAwB,EAAE;AACvC;AACA,KAAK,kBAAkB;AACvB;;AAEA,6BAA6B,mDAAG;AAChC,KAAK,QAAQ,KAAK,EAAE;AACpB;AACA,KAAK,kBAAkB;AACvB;;AAEA;AACA;;AAEO;AACP;AACA;AACA,WAAW,QAAQ,KAAK,EAAE,GAAG,mDAAG;AAChC;AACA,GAAG;AACH;AACA;AACA,gBAAgB,WAAW;;AAE3B,0CAA0C,SAAS,aAAa,aAAa;AAC7E,cAAc,WAAW;;AAEzB;;;AAGA;AACA,IAAI,mDAAG;AACP,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,gBAAgB,gDAAgD;AAChE;AACA;;AAEA,sBAAsB,6CAAM;AAC5B;AACA;AACA;AACA;AACA,gBAAgB,gDAAgD;AAChE;AACA;AAC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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"apollo-server\"), require(\"apollo-server-express\"), require(\"bcrypt\"), require(\"body-parser\"), require(\"compression\"), require(\"cors\"), require(\"dotenv\"), require(\"exif\"), require(\"express\"), require(\"file-system\"), require(\"graphql-playground-middleware-express\"), require(\"graphql-subscriptions\"), require(\"image-size\"), require(\"jsonwebtoken\"), require(\"merge-graphql-schemas\"), require(\"mkdirp\"), require(\"path\"), require(\"progress-stream\"), require(\"rimraf\"), require(\"sequelize\"), require(\"sharp\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"migration-data-model\", [\"apollo-server\", \"apollo-server-express\", \"bcrypt\", \"body-parser\", \"compression\", \"cors\", \"dotenv\", \"exif\", \"express\", \"file-system\", \"graphql-playground-middleware-express\", \"graphql-subscriptions\", \"image-size\", \"jsonwebtoken\", \"merge-graphql-schemas\", \"mkdirp\", \"path\", \"progress-stream\", \"rimraf\", \"sequelize\", \"sharp\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"migration-data-model\"] = factory(require(\"apollo-server\"), require(\"apollo-server-express\"), require(\"bcrypt\"), require(\"body-parser\"), require(\"compression\"), require(\"cors\"), require(\"dotenv\"), require(\"exif\"), require(\"express\"), require(\"file-system\"), require(\"graphql-playground-middleware-express\"), require(\"graphql-subscriptions\"), require(\"image-size\"), require(\"jsonwebtoken\"), require(\"merge-graphql-schemas\"), require(\"mkdirp\"), require(\"path\"), require(\"progress-stream\"), require(\"rimraf\"), require(\"sequelize\"), require(\"sharp\"));\n\telse\n\t\troot[\"migration-data-model\"] = factory(root[\"apollo-server\"], root[\"apollo-server-express\"], root[\"bcrypt\"], root[\"body-parser\"], root[\"compression\"], root[\"cors\"], root[\"dotenv\"], root[\"exif\"], root[\"express\"], root[\"file-system\"], root[\"graphql-playground-middleware-express\"], root[\"graphql-subscriptions\"], root[\"image-size\"], root[\"jsonwebtoken\"], root[\"merge-graphql-schemas\"], root[\"mkdirp\"], root[\"path\"], root[\"progress-stream\"], root[\"rimraf\"], root[\"sequelize\"], root[\"sharp\"]);\n})(global, function(__WEBPACK_EXTERNAL_MODULE_apollo_server__, __WEBPACK_EXTERNAL_MODULE_apollo_server_express__, __WEBPACK_EXTERNAL_MODULE_bcrypt__, __WEBPACK_EXTERNAL_MODULE_body_parser__, __WEBPACK_EXTERNAL_MODULE_compression__, __WEBPACK_EXTERNAL_MODULE_cors__, __WEBPACK_EXTERNAL_MODULE_dotenv__, __WEBPACK_EXTERNAL_MODULE_exif__, __WEBPACK_EXTERNAL_MODULE_express__, __WEBPACK_EXTERNAL_MODULE_file_system__, __WEBPACK_EXTERNAL_MODULE_graphql_playground_middleware_express__, __WEBPACK_EXTERNAL_MODULE_graphql_subscriptions__, __WEBPACK_EXTERNAL_MODULE_image_size__, __WEBPACK_EXTERNAL_MODULE_jsonwebtoken__, __WEBPACK_EXTERNAL_MODULE_merge_graphql_schemas__, __WEBPACK_EXTERNAL_MODULE_mkdirp__, __WEBPACK_EXTERNAL_MODULE_path__, __WEBPACK_EXTERNAL_MODULE_progress_stream__, __WEBPACK_EXTERNAL_MODULE_rimraf__, __WEBPACK_EXTERNAL_MODULE_sequelize__, __WEBPACK_EXTERNAL_MODULE_sharp__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","export const UPLOAD_FOLDER = 'uploads';\nexport const PHOTOS_FOLDER = 'photos';\nexport const SALT_ROUNDS = 10;\nexport const ALBUM = 'album';\nexport const PHOTO = 'photo';\n\n// Responsive resizing\n// Number = width\n// Object = { width, height }\nexport const SIZES = [\n  'original',\n  2560,\n  1440,\n  960,\n  700,\n  360,\n  { longestEdge: 150 },\n];\nexport const COVER_SIZE = 5; // item in SIZES array\nexport const THUMBNAIL_SIZE = 6; // item in SIZES array\nexport const BATCH_CONCURRENCY = 5;\nexport const DELIM = '__';\n","export default (e, models) => {\n  if (e instanceof models.sequelize.ValidationError) {\n    return e.errors.map(error => ({\n      path: error.path,\n      type: error.type,\n      message: error.message,\n    }));\n  }\n  return [{ path: 'name', message: 'something went wrong' }];\n};\n","import dotenv from 'dotenv';\nimport path from 'path';\nimport http from 'http';\nimport express from 'express';\nimport bodyParser from 'body-parser';\nimport cors from 'cors';\nimport compression from 'compression';\nimport jwt from 'jsonwebtoken';\nimport { ApolloServer, makeExecutableSchema } from 'apollo-server-express';\nimport playground from 'graphql-playground-middleware-express';\nimport { fileLoader, mergeTypes, mergeResolvers } from 'merge-graphql-schemas';\nimport models from './models';\nimport seedUser from './models/seedUser';\nimport { refreshTokens } from './services/auth';\nimport { version } from '../package.json';\nimport { PHOTOS_FOLDER } from './constants';\nimport resolversSet from './resolvers';\nimport schemaSet from './schema';\n\ndotenv.config();\n\n// eslint-disable-next-line prefer-destructuring\nconst SECRET = process.env.SECRET;\nconst SECRET2 = process.env.REFRESH_SECRET;\nconst wsUri = process.env.SERVER_WS || 'ws://localhost';\nconst port = process.env.PORT || 3001;\n\nconst typeDefs = mergeTypes(schemaSet);\nconst resolvers = mergeResolvers(resolversSet);\nconst schema = makeExecutableSchema({\n  typeDefs,\n  resolvers,\n});\n\nconst server = new ApolloServer({\n  schema,\n  // TODO: Get auth context\n  //  subscriptions: {\n  //   onConnect: (connectionParams, webSocket) => {\n  //     if (connectionParams) {\n  //       // return validateToken(connectionParams.authToken)\n  //       //   .then(findUser(connectionParams.authToken))\n  //       //   .then(user => ({\n  //       //     currentUser: user,\n  //       //   }));\n\n  //       // onConnect: async ({ token, refreshToken }, webSocket) => {\n  //       //   if (token && refreshToken) {\n  //       //     try {\n  //       //       const { user } = jwt.verify(token, SECRET);\n  //       //       return { models, user };\n  //       //     } catch (err) {\n  //       //       const newTokens = await refreshTokens(token, refreshToken, models, SECRET, SECRET2);\n  //       //       return { models, user: newTokens.user };\n  //       //     }\n  //       //   }\n\n  //       //   return { models };\n  //       // },\n\n\n  //       return { user: 1 };\n  //     }\n\n  //     throw new Error('Missing auth token!');\n  //   },\n  // },\n  // Need to use connection context for subscriptions\n  context: ({ req, connection }) => {\n    if (connection) {\n      // connection.context.x-token\n      return {};\n    }\n    return {\n      models,\n      user: req.user,\n      SECRET,\n      SECRET2,\n    };\n  },\n});\n\nconst graphqlEndpoint = '/graphql';\nconst subscriptionsEndpoint = `${wsUri}:${port}${server.subscriptionsPath}`;\nconst app = express();\nconst corsOptions = { origin: '*' };\n\nconst addUser = async (req, res, next) => {\n  const token = req.headers['x-token'];\n  if (token) {\n    try {\n      const { user } = jwt.verify(token, SECRET);\n      req.user = user;\n    } catch (err) {\n      const refreshToken = req.headers['x-refresh-token'];\n      const newTokens = await refreshTokens(token, refreshToken, models, SECRET, SECRET2);\n      if (newTokens.token && newTokens.refreshToken) {\n        res.set('Access-Control-Expose-Headers', 'x-token, x-refresh-token');\n        res.set('x-token', newTokens.token);\n        res.set('x-refresh-token', newTokens.refreshToken);\n      }\n      req.user = newTokens.user;\n    }\n  }\n  next();\n};\n\napp.use(addUser);\napp.use(bodyParser.json({ limit: '4mb' }));\napp.use(cors(corsOptions));\napp.use(compression());\napp.use('/playground', playground({\n  endpoint: graphqlEndpoint,\n  subscriptionsEndpoint,\n}));\napp.use('/photos', express.static(path.join(__dirname, '../', PHOTOS_FOLDER)));\n\nserver.applyMiddleware({ app });\n\n// Set up subscriptions\nconst httpServer = http.createServer(app);\nserver.installSubscriptionHandlers(httpServer);\n\nprocess.on('SIGINT', () => {\n  process.exit(0);\n});\n\n// Start the socket and graphQl servers\nhttpServer.listen({ port }, async () => {\n  await models.sequelize.sync();\n  await seedUser();\n  console.info(`🚀 Portfolio API version ${version} ready`);\n  console.info(`🚀 Subscriptions ready at ${subscriptionsEndpoint}`);\n});\n","import Sequelize from 'sequelize';\nimport sequelize from './sequelize';\n\nconst Album = sequelize.define('albums', {\n  id: {\n    type: Sequelize.INTEGER,\n    primaryKey: true,\n    autoIncrement: true,\n  },\n  name: {\n    type: Sequelize.STRING,\n    allowNull: false,\n  },\n  slug: Sequelize.STRING,\n  description: Sequelize.TEXT,\n  cover: Sequelize.STRING,\n  coverId: Sequelize.INTEGER,\n  isPublic: {\n    type: Sequelize.BOOLEAN,\n    allowNull: false,\n    defaultValue: true,\n  },\n  views: {\n    type: Sequelize.INTEGER,\n    allowNull: false,\n    defaultValue: 0,\n  },\n  bin: {\n    type: Sequelize.BOOLEAN,\n    allowNull: false,\n    defaultValue: false,\n  },\n}, {\n  indexes: [\n    {\n      name: 'i_album_name',\n      unique: true,\n      fields: ['name'],\n    },\n  ],\n});\n\n\nexport default Album;\n","import Sequelize from 'sequelize';\nimport sequelize from './sequelize';\n\nconst Photo = sequelize.define('photos', {\n  id: {\n    type: Sequelize.INTEGER,\n    primaryKey: true,\n    autoIncrement: true,\n  },\n  name: {\n    type: Sequelize.STRING,\n    allowNull: false,\n  },\n  urls: {\n    type: Sequelize.JSON,\n    allowNull: false,\n  },\n  thumbnail: {\n    type: Sequelize.STRING,\n    allowNull: false,\n  },\n  title: Sequelize.STRING,\n  caption: Sequelize.STRING,\n  width: {\n    type: Sequelize.INTEGER,\n    allowNull: false,\n  },\n  height: {\n    type: Sequelize.INTEGER,\n    allowNull: false,\n  },\n  exposure: Sequelize.INTEGER,\n  shutter: Sequelize.INTEGER,\n  aperture: Sequelize.INTEGER,\n  iso: Sequelize.INTEGER,\n  focalLength: Sequelize.INTEGER,\n  dateTaken: Sequelize.DATE,\n  isPublic: {\n    type: Sequelize.BOOLEAN,\n    allowNull: false,\n    defaultValue: true,\n  },\n  bin: {\n    type: Sequelize.BOOLEAN,\n    allowNull: false,\n    defaultValue: false,\n  },\n},\n{\n  indexes: [\n    {\n      name: 'i_photo_name',\n      unique: true,\n      fields: ['name'],\n    },\n    {\n      name: 'i_photo_title',\n      unique: true,\n      fields: ['title'],\n    },\n  ],\n});\n\nexport default Photo;\n","import dotenv from 'dotenv';\nimport bcrypt from 'bcrypt';\nimport Sequelize from 'sequelize';\nimport sequelize from './sequelize';\nimport { SALT_ROUNDS } from '../constants';\n\n// export const compareHash = (password, hashed) => bcrypt.compareSync(password, hashed);\n\ndotenv.config();\n\nconst { Op } = Sequelize;\n\nconst User = sequelize.define('users', {\n  id: {\n    type: Sequelize.INTEGER,\n    primaryKey: true,\n    autoIncrement: true,\n  },\n  username: {\n    type: Sequelize.STRING,\n    unique: true,\n    allowNull: false,\n  },\n  email: {\n    type: Sequelize.STRING,\n    unique: true,\n    allowNull: false,\n  },\n  password: {\n    type: Sequelize.STRING,\n    allowNull: false,\n  },\n  isAdmin: {\n    type: Sequelize.BOOLEAN,\n    allowNull: false,\n    defaultValue: false,\n  },\n  blocked: Sequelize.BOOLEAN,\n});\n\n// Hash password before committing to db\nUser.beforeCreate((u) => {\n  u.password = bcrypt.hashSync(u.password, SALT_ROUNDS);\n});\n\nexport const findByLogin = async (login) => {\n  let user = await User.findOne({\n    where: { username: login },\n  });\n\n  if (!user) {\n    user = await User.findOne({\n      where: { email: login },\n    });\n  }\n\n  return user;\n};\n\nexport default User;\n","import sequelize from './sequelize';\nimport User, { findByLogin } from './User';\nimport Photo from './Photo';\nimport Album from './Album';\n\n// Associations\nPhoto.belongsTo(User);\nAlbum.belongsTo(User);\nPhoto.belongsToMany(Album, { through: 'album_photos' });\nAlbum.belongsToMany(Photo, { through: 'album_photos', onDelete: 'CASCADE' });\n/**\n * Provides the following accessor methods:\n * Album.getPhotos\n * Album.setPhotos\n * Album.addPhoto(s)\n * Album.removePhoto(s)  .. and likelwise for Photos.getAlbums, etc.\n */\n\nexport default {\n  User,\n  findByLogin,\n  Photo,\n  Album,\n  sequelize,\n};\n\n// TODO: add indexes for sort and search cols\n","import models from './index';\n\nconst { User } = models;\n\nexport default async () => {\n  // Create default user\n  const username = process.env.USERNAME || 'test';\n  const email = process.env.EMAIL || 'test@test.com';\n  const password = process.env.PASSWORD || 'password';\n\n  const found = await User.findOne({ where: { email } });\n\n  if (!found) {\n    await User.create({\n      username, email, password, isAdmin: true,\n    });\n  }\n};\n","import dotenv from 'dotenv';\nimport Sequelize from 'sequelize';\n\ndotenv.config();\n\nexport default new Sequelize(\n  process.env.PGDATABASE,\n  process.env.PGUSER,\n  process.env.PGPASSWORD,\n  {\n    host: process.env.PGHOST,\n    port: process.env.PGPORT,\n    dialect: 'postgres',\n    pool: {\n      max: 5,\n      min: 0,\n      acquire: 30000,\n      idle: 10000,\n    },\n    logging: false,\n  },\n);\n","import { PubSub } from 'apollo-server';\n\nconst pubsub = new PubSub();\nexport default pubsub;\n\nexport const UPLOAD_STARTED = 'UPLOAD_STARTED';\nexport const UPLOAD_PROGRESS = 'UPLOAD_PROGRESS';\n\nexport const emitUploadStarted = filename =>\n  pubsub.publish(UPLOAD_STARTED, {\n    uploadStarted: filename,\n  });\n\nexport const emitUploadProgress = (filename, percentage) =>\n  pubsub.publish(UPLOAD_PROGRESS, {\n    uploadProgress: { filename, percentage },\n  });\n","import Sequelize from 'sequelize';\nimport requiresAuth from '../services/permissions';\nimport formatErrors from '../formatErrors';\nimport { COVER_SIZE } from '../constants';\n\nconst { Op } = Sequelize;\n\nconst AlbumsResolver = {\n  Query: {\n    allAlbums: requiresAuth.createResolver(\n      (parent, { id }, { models, user }) => {\n        const filter = id\n          ? {\n            [Op.and]: {\n              userId: { [Op.eq]: user.id },\n              bin: { [Op.eq]: false },\n              id: { [Op.eq]: id },\n            },\n          }\n          : {\n            [Op.and]: {\n              userId: { [Op.eq]: user.id },\n              bin: { [Op.eq]: false },\n            },\n          };\n        return models.Album.findAll({\n          where: filter,\n          include: [{ model: models.Photo, as: 'photos' }],\n          order: [['name']],\n        })\n          .then(result => ({\n            data: result.map(r => r.dataValues),\n            errors: null,\n          }))\n          .catch(err => ({ data: [], errors: formatErrors(err, models) }));\n      },\n    ),\n\n    // NOTE: Hard-coded user id\n    getPublicAlbums: (parent, args, { models, userId = 1 }) =>\n      models.Album.findAll({\n        where: {\n          [Op.and]: {\n            userId: { [Op.eq]: userId },\n            isPublic: { [Op.eq]: true },\n            bin: { [Op.eq]: false },\n            cover: { [Op.ne]: null },\n          },\n        },\n        include: [{ model: models.Photo, as: 'photos' }],\n        order: [['createdAt', 'DESC']],\n      })\n        .then(result => ({\n          data: result.map(r => r.dataValues),\n          errors: null,\n        }))\n        .catch(err => ({ data: [], errors: formatErrors(err, models) })),\n\n    getAlbum: (parent, { albumId }, { models }) =>\n      models.Album.findOne({\n        where: {\n          [Op.and]: {\n            id: { [Op.eq]: albumId },\n            isPublic: { [Op.eq]: true },\n            bin: { [Op.eq]: false },\n          },\n        },\n        include: [{ model: models.Photo, as: 'photos' }],\n      })\n        .then(result => ({\n          data: result.dataValues,\n          errors: null,\n        }))\n        .catch(err => ({ data: null, errors: formatErrors(err, models) })),\n  },\n\n  Mutation: {\n    addAlbum: requiresAuth.createResolver(\n      async (parent, { album }, { models, user }) => {\n        const { id, ...details } = album;\n        return !!models.Album.create({ ...details, userId: user.id });\n      },\n    ),\n\n    updateAlbum: requiresAuth.createResolver(\n      async (parent, { album }, { models }) => {\n        const { id, ...details } = album;\n        return !!models.Album.update({ ...details }, { where: { id } });\n      },\n    ),\n\n    addPhotosToAlbum: requiresAuth.createResolver(\n      async (parent, { albumId, photoIds }, { models }) => {\n        try {\n          const album = await models.Album.findById(albumId);\n          if (!album) { return false; }\n\n          // Set first photo as default album cover if none set\n          if (!album.dataValues.cover) {\n            const firstPhoto = await models.Photo.findById(photoIds[0]);\n            // Set cover photo id and url\n            const cover = firstPhoto.dataValues.urls[COVER_SIZE];\n            const coverId = firstPhoto.dataValues.id;\n            await models.Album.update({ cover, coverId }, { where: { id: albumId } });\n          }\n\n          // Add photos to the album\n          const result = await album.addPhotos(photoIds);\n          return { data: !!result, errors: null };\n        } catch (err) {\n          return { data: false, errors: formatErrors(err, models) };\n        }\n      },\n    ),\n\n    removePhotosFromAlbum: requiresAuth.createResolver(\n      async (parent, { albumId, photoIds }, { models }) => {\n        try {\n          const album = await models.Album.findById(albumId);\n          if (!album) { return false; }\n          const result = await album.removePhotos(photoIds);\n          return { data: !!result, errors: null };\n        } catch (err) {\n          return { data: false, errors: formatErrors(err, models) };\n        }\n      },\n    ),\n\n    addView: async (parent, { albumId }, { models }) => {\n      const album = await models.Album.findById(albumId);\n      let { views } = album.dataValues;\n      views += 1;\n      return !!album.update({ views });\n    },\n\n    deleteAlbum: requiresAuth.createResolver(\n      async (parent, { albumId }, { models }) =>\n        !!models.Album.destroy({ where: { id: albumId } }),\n    ),\n  },\n};\n\nexport default AlbumsResolver;\n","import Sequelize from 'sequelize';\nimport requiresAuth from '../services/permissions';\nimport { deletePhotoFiles } from '../services/file';\nimport formatErrors from '../formatErrors';\nimport { ALBUM, PHOTO } from '../constants';\n\nconst { Op } = Sequelize;\n\nconst BinResolver = {\n  Query: {\n    allBinItems: requiresAuth.createResolver(\n      (parent, args, { models, user }) => {\n        const albums = models.Album.findAll({\n          where: {\n            [Op.and]: {\n              userId: { [Op.eq]: user.id },\n              bin: { [Op.eq]: true },\n            },\n          },\n          include: [{ model: models.Photo, as: 'photos' }],\n        })\n          .then(result => ({\n            albums: result.map(r => r.dataValues),\n            errors: null,\n          }))\n          .catch(err => ({ photos: [], errors: formatErrors(err, models) }));\n\n        const photos = models.Photo.findAll({\n          where: {\n            [Op.and]: {\n              userId: { [Op.eq]: user.id },\n              bin: { [Op.eq]: true },\n            },\n          },\n        })\n          .then(result => ({\n            photos: result.map(r => r.dataValues),\n            errors: null,\n          }))\n          .catch(err => ({ albums: [], errors: formatErrors(err, models) }));\n\n        // NOTE: This does not concatenate errors; last one wins!\n        return Promise.all([albums, photos])\n          .then(result => result.reduce((prev, cur) => ({ ...prev, ...cur }), {}))\n          .catch(err => ({ albums: [], photos: [], errors: formatErrors(err, models) }));\n      },\n    ),\n  },\n\n  Mutation: {\n    addToBin: requiresAuth.createResolver(\n      async (parent, { type, ids, albumId }, { models, user }) => {\n        if (type === ALBUM) {\n          try {\n            const result = await models.Album.update({ bin: true }, {\n              returning: true,\n              where: {\n                [Op.and]: {\n                  userId: { [Op.eq]: user.id },\n                  id: { [Op.in]: ids },\n                },\n              },\n            });\n            return !!result;\n          } catch (err) {\n            return false;\n          }\n        }\n        if (type === PHOTO) {\n          try {\n            const result = await models.Photo.update({ bin: true }, {\n              returning: true,\n              where: {\n                [Op.and]: {\n                  userId: { [Op.eq]: user.id },\n                  id: { [Op.in]: ids },\n                },\n              },\n            });\n            // If any cover ids are in the removed set, set them to null\n            const albums = await models.Album.findAll();\n            albums.forEach((album) => {\n              if (ids.includes(album.dataValues.coverId)) {\n                models.Album.update(\n                  { cover: null, coverId: null },\n                  { where: { id: album.dataValues.id } },\n                );\n              }\n            });\n\n            return !!result;\n          } catch (err) {\n            return false;\n          }\n        }\n        return false;\n      },\n    ),\n\n    restore: requiresAuth.createResolver(\n      async (parent, args, { models, user }) => {\n        try {\n          const restoreAlbums = await models.Album.update({ bin: false }, {\n            returning: true,\n            where: {\n              [Op.and]: {\n                userId: { [Op.eq]: user.id },\n                bin: { [Op.eq]: true },\n              },\n            },\n          });\n          const restorePhotos = await models.Photo.update({ bin: false }, {\n            returning: true,\n            where: {\n              [Op.and]: {\n                userId: { [Op.eq]: user.id },\n                bin: { [Op.eq]: true },\n              },\n            },\n          });\n          return true;\n        } catch (err) {\n          return false;\n        }\n      },\n    ),\n\n    emptyBin: requiresAuth.createResolver(\n      async (parent, args, { models, user }) => {\n        try {\n          await models.Album.destroy({\n            returning: true,\n            where: {\n              [Op.and]: {\n                userId: { [Op.eq]: user.id },\n                bin: { [Op.eq]: true },\n              },\n            },\n          });\n          // Need to remove photo files as well as database entries\n          const results = await models.Photo.findAll({\n            attributes: ['id', 'urls'],\n            where: {\n              [Op.and]: {\n                userId: { [Op.eq]: user.id },\n                bin: { [Op.eq]: true },\n              },\n            },\n          });\n          results.forEach(async (result) => {\n            const { id, urls } = result.dataValues;\n            await deletePhotoFiles(urls);\n            await models.Photo.destroy({ where: { id } });\n          });\n          return true;\n        } catch (err) {\n          return false;\n        }\n      },\n    ),\n  },\n};\n\nexport default BinResolver;\n","import albums from './albums';\nimport photos from './photos';\nimport users from './users';\nimport bin from './bin';\n\nexport default [\n  albums,\n  photos,\n  users,\n  bin,\n];\n","import Sequelize from 'sequelize';\nimport { withFilter } from 'graphql-subscriptions';\nimport {\n  storeUpload, setProgress, cleanUpload, deletePhotoFiles,\n} from '../services/file';\nimport requiresAuth from '../services/permissions';\nimport formatErrors from '../formatErrors';\nimport processFile from '../services/processFile';\nimport batch from '../services/batch';\nimport pubsub, { UPLOAD_STARTED, UPLOAD_PROGRESS } from '../pubsub';\n\nconst { Op } = Sequelize;\n\nconst PhotosResolver = {\n  Subscription: {\n    uploadStarted: {\n      subscribe: () => pubsub.asyncIterator(UPLOAD_STARTED),\n    },\n    uploadProgress: {\n      subscribe: withFilter(\n        () => pubsub.asyncIterator(UPLOAD_PROGRESS),\n        (payload, args) => payload.uploadProgress.filename === args.filename,\n      ),\n      // subscribe: requiresAuth.createResolver(withFilter(\n      //   () => pubsub.asyncIterator(UPLOAD_PROGRESS),\n      //   (payload, args) => payload.uploadProgress.filename === args.filename,\n      // )),\n    },\n  },\n\n  Query: {\n    allPhotos: (parent, { albumId, orderBy }, { models, userId = 1 }) => {\n      const filter = albumId\n        ? {\n          [Op.and]: {\n            userId: { [Op.eq]: userId },\n            bin: { [Op.eq]: false },\n            '$albums.id$': { [Op.eq]: albumId },\n          },\n        }\n        : {\n          [Op.and]: {\n            userId: { [Op.eq]: userId },\n            bin: { [Op.eq]: false },\n          },\n        };\n      const order = orderBy ? orderBy.split('_') : ['id', 'DESC'];\n\n      return models.Photo.findAll({\n        include: [{\n          model: models.Album,\n          attributes: ['id'],\n          through: 'album_photos',\n        }],\n        where: filter,\n        order: [order],\n      })\n        .then(result => ({\n          data: result.map(r => r.dataValues),\n          errors: null,\n        }))\n        .catch(err => ({ data: [], errors: formatErrors(err, models) }));\n    },\n\n    publicPhotos: async (parent, { albumId, orderBy }, { models, userId = 1 }) => {\n      // Determine whether albumId is slug or number\n      let id;\n      if (!isNaN(parseInt(albumId, 10))) {\n        id = parseInt(albumId, 10);\n      } else {\n        // Slug\n        const result = await models.Album.findOne({\n          where: { slug: { [Op.eq]: albumId } },\n        });\n        if (!result) {\n          return {\n            data: [],\n            errors: Error('No album by that name'),\n          };\n        }\n        id = result.dataValues.id;\n      }\n\n      const filter = albumId\n        ? {\n          [Op.and]: {\n            userId: { [Op.eq]: userId },\n            bin: { [Op.eq]: false },\n            isPublic: { [Op.eq]: true },\n            '$albums.id$': { [Op.eq]: id },\n          },\n        }\n        : {\n          [Op.and]: {\n            userId: { [Op.eq]: userId },\n            bin: { [Op.eq]: false },\n          },\n        };\n      const order = orderBy ? orderBy.split('_') : ['id', 'DESC'];\n\n      return models.Photo.findAll({\n        include: [{\n          model: models.Album,\n          attributes: ['id'],\n          through: 'album_photos',\n        }],\n        where: filter,\n        order: [order],\n      })\n        .then(result => ({\n          data: result.map(r => r.dataValues),\n          errors: null,\n        }))\n        .catch(err => ({ data: [], errors: formatErrors(err, models) }));\n    },\n  },\n\n  Mutation: {\n    uploadPhoto: requiresAuth.createResolver(\n      async (parent, { file }, { models, user, totalUploadSize }) => {\n        const { stream, filename, mimetype } = await file;\n\n        // Image files only (jpg)\n        if (mimetype !== 'image/jpeg') {\n          console.error(`User tried to upload a file with mimetype: ${mimetype}`);\n          return { success: false, error: 'You cannot upload this type of file' };\n        }\n\n        try {\n          // const progress = setProgress(size, filename);\n          await storeUpload(stream, filename);\n          // await storeUpload(stream, filename, progress);\n\n          // Process the file\n          const {\n            exif, error, urls, thumbnail, name,\n          } = await processFile(filename);\n\n          console.log('Processed', filename);\n\n          // Write to database\n          const photoData = {\n            ...exif, urls, thumbnail, name, userId: user.id,\n          };\n          await models.Photo.create(photoData);\n\n          await cleanUpload(filename);\n\n          return {\n            name, success: true, exif: JSON.stringify(exif), error, thumbnail,\n          };\n        } catch (err) {\n          console.error(`FAIL: Unable to upload ${filename}`);\n          console.error(err.message);\n          return { success: false, error: formatErrors(err, models) };\n        }\n      },\n    ),\n\n    uploadPhotos: requiresAuth.createResolver(\n      async (parent, { files, sizes = [] }, ctx) => {\n        const totalUploadSize = sizes.reduce((a, b) => a + b, 0);\n        const context = { ...ctx, totalUploadSize };\n\n        return batch()(\n          files,\n          PhotosResolver.Mutation.uploadPhoto,\n          { parent, argName: 'file', context },\n          sizes,\n        );\n      },\n    ),\n\n    updatePhoto: requiresAuth.createResolver(\n      async (parent, { photo }, { models }) => {\n        const { id, ...details } = photo;\n        return !!models.Photo.update(details, { where: { id } });\n      },\n    ),\n\n    deletePhoto: requiresAuth.createResolver(\n      async (parent, { id }, { models }) => {\n        const photo = await models.Photo.findOne({ where: { id } });\n        const files = photo.dataValues.urls;\n        await deletePhotoFiles(files);\n        return !!models.Photo.destroy({ where: { id } });\n      },\n    ),\n  },\n};\n\nexport default PhotosResolver;\n","import { tryLogin } from '../services/auth';\nimport requiresAuth from '../services/permissions';\nimport formatErrors from '../formatErrors';\n\nexport default {\n  Mutation: {\n    login: (parent, { username, password }, { models, SECRET, SECRET2 }) =>\n      tryLogin(username, password, models, SECRET, SECRET2),\n\n    addUser: requiresAuth.createResolver((parent, args, { models }) =>\n      models.User.create(args)\n        .then(result => ({ id: result.id, errors: null }))\n        .catch(err => ({ id: null, errors: formatErrors(err, models) }))),\n  },\n};\n","export default `\n  type Album {\n    id: Int!\n    name: String!\n    slug: String\n    description: String\n    cover: String\n    coverId: Int\n    views: Int!\n    isPublic: Boolean!\n    createdAt: String!\n    photos: [Photo!]\n  }\n\n  input AlbumInput {\n    id: Int\n    name: String\n    slug: String\n    description: String\n    cover: String\n    coverId: Int\n    isPublic: Boolean\n  }\n\n  type AlbumResponse {\n    data: Album\n    errors: [Error!]\n  }\n\n  type AlbumsResponse {\n    data: [Album!]\n    errors: [Error!]\n  }\n\n  type AlbumUpdateResponse {\n    data: Boolean!\n    errors: [Error!]\n  }\n\n  type Query {\n    allAlbums(id: Int): AlbumsResponse!\n    getPublicAlbums: AlbumsResponse!\n    getAlbum(albumId: Int!): AlbumResponse!\n  }\n\n  type Mutation {\n    addAlbum(album: AlbumInput!): Boolean!\n    updateAlbum(album: AlbumInput!): Boolean!\n    addPhotosToAlbum(albumId: Int!, photoIds: [Int!]!): AlbumUpdateResponse!\n    removePhotosFromAlbum(albumId: Int!, photoIds: [Int!]!): AlbumUpdateResponse!\n    addView(albumId: Int!): Boolean!\n    deleteAlbum(albumId: Int!): Boolean!\n  }\n`;\n\n// setCover(albumId: Int!, photoId: Int!): AlbumUpdateResponse!\n","export default `\n  type BinResponse {\n    albums: [Album!]\n    photos: [Photo!]\n    errors: [Error!]\n  }\n\n  type Query {\n    allBinItems: BinResponse!\n  }\n\n  type Mutation {\n    addToBin(type: String!, ids: [Int!]!, albumId: Int): Boolean!\n    restore: Boolean!\n    emptyBin: Boolean!\n  }\n`;\n","import albums from './albums';\nimport photos from './photos';\nimport users from './users';\nimport bin from './bin';\n\nexport default [\n  albums,\n  photos,\n  users,\n  bin,\n];\n","export default `\n  scalar Upload\n\n  enum PhotoOrderByInput {\n    id_ASC\n    id_DESC\n    title_ASC\n    title_DESC\n    dateTaken_ASC\n    dateTaken_DESC\n    createdAt_ASC\n    createdAt_DESC\n  }\n\n  type UploadResponse {\n    name: String!\n    success: Boolean!\n    exif: String\n    error: String\n    thumbnail: String\n  }\n\n  type Photo {\n    id: Int!\n    name: String!\n    urls: [String]!\n    thumbnail: String!\n    title: String\n    caption: String\n    width: Int!\n    height: Int!\n    exposure: Int\n    shutter: Int\n    aperture: Int\n    iso: Int\n    focalLength: Int\n    dateTaken: String\n    isPublic: Boolean!\n    createdAt: String!\n  }\n\n  input PhotoInput {\n    id: Int!\n    name: String\n    title: String\n    caption: String\n    isPublic: Boolean\n  }\n\n  type PhotoResponse {\n    data: [Photo!]\n    errors: [Error!]\n  }\n\n  type Progress {\n    filename: String\n    percentage: Int\n  }\n\n  type Query {\n    allPhotos(albumId: Int, orderBy: PhotoOrderByInput): PhotoResponse!\n    publicPhotos(albumId: String, orderBy: PhotoOrderByInput): PhotoResponse!\n  }\n\n  type Mutation {\n    uploadPhoto(file: Upload!): UploadResponse!\n    uploadPhotos(files: [Upload!]!, sizes: [Int!]): [UploadResponse!]!\n    updatePhoto(photo: PhotoInput!): Boolean!\n    deletePhoto(id: Int!): Boolean!\n  }\n\n  type Subscription {\n    uploadStarted: String\n    uploadProgress(filename: String!): Progress\n  }\n`;\n","export default `\n  type Error {\n    path: String\n    message: String\n    type: String\n  }\n\n  type createRecordResponse {\n    id: Int\n    errors: [Error!]\n  }\n\n  type LoginResponse {\n    success: Boolean!\n    token: String\n    refreshToken: String\n    errors: [Error!]\n  }\n\n  type Mutation {\n    addUser(username: String!, email: String!, password: String!, isAdmin: Boolean): createRecordResponse!\n    login(username: String!, password: String!): LoginResponse!\n  }\n`;\n","class TaskQueue {\n  constructor(concurrency = 1) {\n    this.concurrency = concurrency;\n    this.running = 0;\n    this.queue = [];\n  }\n\n  pushTask(task) {\n    this.queue.push(task);\n    this.next();\n  }\n\n  next() {\n    while (this.running < this.concurrency && this.queue.length) {\n      const task = this.queue.shift();\n      // task(() => {\n      task().then(() => {\n        this.running -= 1;\n        this.next();\n      });\n      this.running += 1;\n    }\n  }\n\n  empty() {\n    this.queue = [];\n  }\n}\n\nexport default TaskQueue;\n","import jwt from 'jsonwebtoken';\nimport bcrypt from 'bcrypt';\n\nexport const createTokens = async (user, secret, secret2) => {\n  const {\n    id, username, isAdmin, ...rest\n  } = user;\n\n  const createToken = jwt.sign(\n    { user: { id, username, isAdmin } },\n    secret,\n    { expiresIn: '1d' },\n  );\n\n  const createRefreshToken = jwt.sign(\n    { user: { id } },\n    secret2,\n    { expiresIn: '1w' },\n  );\n\n  return [createToken, createRefreshToken];\n};\n\nexport const refreshTokens = async (token, refreshToken, models, SECRET, SECRET2) => {\n  let userId = 0;\n  try {\n    const { user: { id } } = jwt.decode(refreshToken);\n    userId = id;\n  } catch (err) {\n    return {};\n  }\n  if (!userId) { return {}; }\n\n  const user = await models.User.findOne({ where: { id: userId }, raw: true });\n  if (!user) { return {}; }\n\n  const refreshSecret = user.password + SECRET2;\n\n\n  try {\n    jwt.verify(refreshToken, refreshSecret);\n  } catch (err) {\n    console.log('Unable to verify refreshToken');\n    return {};\n  }\n\n  const [newToken, newRefreshToken] = await createTokens(user, SECRET, refreshSecret);\n  return {\n    token: newToken,\n    refreshToken: newRefreshToken,\n    user,\n  };\n};\n\nexport const tryLogin = async (username, password, models, SECRET, SECRET2) => {\n  const user = await models.findByLogin(username);\n  if (!user) {\n    return {\n      success: false,\n      errors: [{ path: 'login', message: 'Wrong login details' }],\n    };\n  }\n\n  const valid = await bcrypt.compare(password, user.password);\n  if (!valid) {\n    // bad password\n    return {\n      success: false,\n      errors: [{ path: 'login', message: 'Wrong login details' }],\n    };\n  }\n  const refreshTokenSecret = user.password + SECRET2;\n  const [token, refreshToken] = await createTokens(user, SECRET, refreshTokenSecret);\n\n  return {\n    success: true,\n    token,\n    refreshToken,\n  };\n};\n","import TaskQueue from './TaskQueue';\nimport { BATCH_CONCURRENCY } from '../constants';\n\nconst limitConcurrency = (con) => {\n  if (!con) { return BATCH_CONCURRENCY; }\n  if ((typeof con !== 'number') || con < 1) {\n    return 1;\n  }\n  if (con > BATCH_CONCURRENCY) {\n    return BATCH_CONCURRENCY;\n  }\n  return con;\n};\n\nexport const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\nexport default concurrency =>\n  async (records, resolver, params, sizes = []) => {\n    const queue = new TaskQueue(limitConcurrency(concurrency));\n    const batchResults = [];\n    let result;\n\n    await new Promise((resolve, reject) => {\n      if (!records || records.length === 0) { resolve(batchResults); }\n\n      let completed = 0;\n      const increment = () => {\n        completed += 1;\n        if (completed === records.length) { resolve(batchResults); }\n      };\n\n      records.forEach((record, i) => {\n        const task = async () => {\n          try {\n            // Resolver signature is (parent, args, context)\n            const { parent, argName, context } = params;\n            const size = sizes ? sizes[i] : null; // Upload size for photos\n            const args = { [argName]: record, size };\n            result = await resolver(parent, args, context);\n            if (result) { batchResults.push(result); }\n            increment();\n          } catch (err) {\n            increment();\n            queue.empty();\n            // reject here to stop the batch on a general error\n            reject(Error(`Batch upload failed: ${err.message}`));\n          }\n        };\n        queue.pushTask(task);\n      });\n    });\n    return batchResults;\n  };\n","import path from 'path';\nimport { ExifImage } from 'exif';\nimport sizeOf from 'image-size';\n\n// Convert '2015:07:11 11:56:35' to date\nconst convertDate = (date) => {\n  if (!date) { return null; }\n  const dateParts = date.split(' ');\n  const dateString = [dateParts[0].replace(/:/gm, '-'), dateParts[1]].join('T');\n  return new Date(dateString);\n};\n\n// TODO: read title and caption\nconst filterExif = (data) => {\n  if (!data) { return {}; }\n  return {\n    title: null,\n    caption: data.image && data.image.ImageDescription,\n    exposure: data.exif && data.exif.ExposureTime,\n    shutter: data.exif && data.exif.ShutterSpeedValue,\n    aperture: data.exif && data.exif.FNumber,\n    iso: data.exif && data.exif.ISO,\n    focalLength: data.exif && data.exif.FocalLength,\n    dateTaken: data.exif && convertDate(data.exif.CreateDate),\n  };\n};\n\nexport default filename => new Promise((resolve) => {\n  const file = path.join(__dirname, '../../uploads', filename);\n  // eslint-disable-next-line no-new\n  new ExifImage({ image: file }, ((error, exifData) => {\n    resolve({ ...filterExif(exifData), ...sizeOf(file) });\n  }));\n});\n","import path from 'path';\nimport rimraf from 'rimraf';\nimport fs, { createWriteStream } from 'file-system';\nimport progressStream from 'progress-stream';\nimport { UPLOAD_FOLDER, PHOTOS_FOLDER } from '../constants';\nimport { ROOT, PHOTO_URL } from './utils';\nimport { emitUploadStarted, emitUploadProgress } from '../pubsub';\n\n// TODO: subscription\n/**\n * This function sets a subscription emitter for upload progress. The progress object exposes\n * properties for transferred (b), remaining (b), length (b) and percentage.\n * @param {*} size in bytes\n * @param {*} filename\n */\nexport const setProgress = (size, filename) =>\n  progressStream(\n    { length: size, time: 10 },\n    progress => console.log(filename, Math.round(progress.percentage))\n    || emitUploadProgress(filename, Math.round(progress.percentage)),\n  );\n\n// TODO: make progress work!\nexport const storeUpload = (stream, filename, progress) =>\n  new Promise((resolve, reject) => {\n    const storePath = path.join(ROOT, UPLOAD_FOLDER, filename);\n    if (progress) {\n      /* stream\n          .pipe(progress)\n          .pipe(createWriteStream(storePath))\n          .on('finish', () => resolve())\n          .on('error', err => reject(err)); */\n    } else {\n      stream\n        .on('error', (error) => {\n          if (stream.truncated) {\n            fs.unlinkSync(storePath);\n          }\n          reject(error);\n        })\n        .pipe(createWriteStream(storePath))\n        .on('finish', () => resolve())\n        .on('error', err => reject(err));\n    }\n  });\n\nconst deleteFile = (folder, filename) => new Promise((resolve) => {\n  const file = path.join(ROOT, folder, filename);\n  rimraf(file, {}, (error) => {\n    if (error) {\n      console.log(`Unable to delete ${filename}`);\n    }\n    resolve();\n  });\n});\n\nexport const deletePhotoFiles = files =>\n  new Promise(async (resolve, reject) => {\n    if (files && files.length) {\n      // Replace any non-null http url with ROOT\n      const deNulledList = files.filter(n => n);\n      const localFiles = deNulledList.map(f => f && f.replace(PHOTO_URL, ''));\n      try {\n        await Promise.all(localFiles.map(f => deleteFile(PHOTOS_FOLDER, f)));\n        resolve();\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n\nconst deleteAllFiles = folder => new Promise((resolve) => {\n  rimraf(path.join(ROOT, folder, '/*'), {}, (error) => {\n    if (error) {\n      console.log(`Unable to clean files folder: ${error}`);\n    }\n    resolve();\n  });\n});\n\nexport const cleanUploads = () => deleteAllFiles(UPLOAD_FOLDER);\n\nexport const cleanUpload = filename => deleteFile(UPLOAD_FOLDER, filename);\n","const createResolver = (resolver) => {\n  const baseResolver = resolver;\n  baseResolver.createResolver = (childResolver) => {\n    const newResolver = async (parent, args, context, info) => {\n      await resolver(parent, args, context, info);\n      return childResolver(parent, args, context, info);\n    };\n    return createResolver(newResolver);\n  };\n  return baseResolver;\n};\n\n// requiresAuth\nexport default createResolver((parent, args, { user }) => {\n  if (!user || !user.id) {\n    throw new Error('Not authenticated');\n  }\n});\n\n// export const requiresTeamAccess = createResolver(\n//   async (parent, { channelId }, { user, models },\n//   ) => {\n//     if (!user || !user.id) {\n//       throw new Error('Not authenticated');\n//     }\n//     // check if part of the team\n//     const channel = await models.Channel.findOne({ where: { id: channelId } });\n//     const member = await models.Member.findOne({\n//       where: { teamId: channel.teamId, userId: user.id },\n//     });\n//     if (!member) {\n//       throw new Error(\"You have to be a member of the team to subcribe to it's messages\");\n//     }\n//   },\n// );\n\n// export const directMessageSubscription = createResolver(\n//   async (parent, { teamId, userId }, { user, models },\n//   ) => {\n//     if (!user || !user.id) {\n//       throw new Error('Not authenticated');\n//     }\n\n//     const members = await models.Member.findAll({\n//       where: {\n//         teamId,\n//         [models.sequelize.Op.or]: [{ userId }, { userId: user.id }],\n//       },\n//     });\n\n//     if (members.length !== 2) {\n//       throw new Error('Something went wrong');\n//     }\n//   },\n// );\n","import getExifData from './exif';\nimport { resizeImage } from './resize';\n\nexport default file => new Promise(async (resolve, reject) => {\n  try {\n    const exif = await getExifData(file);\n    const {\n      thumbnail, urls, error, name,\n    } = await resizeImage(file, exif);\n    resolve({\n      exif, error, urls, thumbnail, name,\n    });\n  } catch (e) {\n    reject(e);\n  }\n});\n","import path from 'path';\nimport fs from 'file-system';\nimport dotenv from 'dotenv';\nimport mkdirp from 'mkdirp';\nimport sharp from 'sharp';\nimport {\n  UPLOAD_FOLDER, PHOTOS_FOLDER, SIZES, DELIM, THUMBNAIL_SIZE,\n} from '../constants';\nimport { ROOT } from './utils';\n\ndotenv.config();\n\nconst BASE_URL = path.join(ROOT, PHOTOS_FOLDER);\n\n// Write any missing folders in a file path\nconst writePath = (filePath, cb) => {\n  mkdirp(path.dirname(filePath), (err) => {\n    if (err) return cb(err);\n    return cb();\n  });\n};\n\nconst fileExists = filePath => fs.existsSync(filePath);\n\nconst getNewFileVersion = (filePath, version = 0) => {\n  if (!fileExists(filePath)) {\n    return filePath;\n  }\n  const folder = path.dirname(filePath);\n  const newFilename = path.basename(filePath);\n  const ext = path.extname(newFilename);\n  const body = newFilename.split('.')[0].split(`${DELIM}${version}`)[0];\n  return getNewFileVersion(path.join(folder, `${body}${DELIM}${version + 1}${ext}`), version + 1);\n};\n\nconst safeName = f => f.replace(/[^a-z0-9._-]/gi, '').toLowerCase();\n\nconst makeFolderName = (fileName) => {\n  const d = new Date();\n  const y = d.getFullYear().toString();\n  const m = (d.getMonth() + 1).toString();\n  const day = d.getDate().toString();\n  const filePath = path.join(BASE_URL, y, m, day, safeName(fileName || ''));\n  return getNewFileVersion(filePath);\n};\n\nconst makeRelativePath = absolutePath => `/${absolutePath.replace(ROOT, '')}`;\n\nconst getDimensions = (size) => {\n  if (!size || size === 'original') {\n    return '';\n  }\n  // Set filename with size and an 'h' for fixed-height crops and w for width\n  if (size.height) { return `-${size.height}h`; }\n  if (size.width) { return `-${size.width}w`; }\n  return `-${size}w`;\n};\n\nconst imageIsTooSmall = (actualWidth, resizeTo) => {\n  if (resizeTo === 'original') { return false; }\n  const resizeWidth = resizeTo.width ? resizeTo.width : resizeTo;\n  return (actualWidth < resizeWidth);\n};\n\n// Return a size object oriented to resize the longest edge\nconst longestEdge = ({ width, height }, resizeTo) =>\n  // const aspect = width / height;\n  ((width >= height)\n    ? { width: resizeTo, height: null }\n    : { width: null, height: resizeTo });\n\n// eslint-disable-next-line import/prefer-default-export\nexport const resize = (filename, exif) => size => new Promise((resolve, reject) => {\n  if (imageIsTooSmall(exif.width, size)) {\n    resolve(null); // Don't upsample!\n  } else {\n    if (size.longestEdge) {\n      size = longestEdge(exif, size.longestEdge); // Resize to correct orientation\n    }\n    const inPath = path.join(__dirname, `../../${UPLOAD_FOLDER}`, filename);\n    const ext = path.extname(filename);\n    const outName = makeFolderName(`${filename.split(ext)[0]}${getDimensions(size)}${ext}`);\n    try {\n      writePath(outName, async () => {\n        const outPath = path.join(outName);\n        if (typeof size === 'number') {\n          await sharp(inPath)\n            .resize(size)\n            .toFormat('jpeg')\n            .toFile(outPath);\n        } else {\n          await sharp(inPath)\n            .resize(size.width, size.height)\n            .toFormat('jpeg')\n            .toFile(outPath);\n        }\n        // Convert file paths to relative server paths\n        // FIXME: needs a leading / in built mode\n        console.log({ ROOT, outPath, relative: makeRelativePath(outPath) });\n\n        resolve(makeRelativePath(outPath));\n      });\n    } catch (e) {\n      console.log('resize error:', e.message);\n      reject(e);\n    }\n  }\n});\n\nexport const resizeImage = async (filename, exif) => {\n  try {\n    const name = path.basename(filename);\n    const urls = await Promise.all(SIZES.map(resize(filename, exif)));\n    return {\n      name, urls, thumbnail: urls[THUMBNAIL_SIZE], error: null,\n    };\n  } catch (err) {\n    return { url: null, error: err };\n  }\n};\n","\nimport path from 'path';\nimport { PHOTOS_FOLDER } from '../constants';\n\nconst env = process.env.NODE_ENV;\nconsole.log('TCL: env', env);\n\nexport const HTTP_URL = `${process.env.SERVER_URI}:${process.env.PORT}`;\nconsole.log('TCL: HTTP_URL', HTTP_URL);\n\nexport const PHOTO_URL = `${HTTP_URL}/${PHOTOS_FOLDER}`;\n\nexport const ROOT = (env && env === 'development')\n  ? path.join(__dirname, '../../')\n  : path.join(__dirname, '../');\n","module.exports = __WEBPACK_EXTERNAL_MODULE_apollo_server__;","module.exports = __WEBPACK_EXTERNAL_MODULE_apollo_server_express__;","module.exports = __WEBPACK_EXTERNAL_MODULE_bcrypt__;","module.exports = __WEBPACK_EXTERNAL_MODULE_body_parser__;","module.exports = __WEBPACK_EXTERNAL_MODULE_compression__;","module.exports = __WEBPACK_EXTERNAL_MODULE_cors__;","module.exports = __WEBPACK_EXTERNAL_MODULE_dotenv__;","module.exports = __WEBPACK_EXTERNAL_MODULE_exif__;","module.exports = __WEBPACK_EXTERNAL_MODULE_express__;","module.exports = __WEBPACK_EXTERNAL_MODULE_file_system__;","module.exports = __WEBPACK_EXTERNAL_MODULE_graphql_playground_middleware_express__;","module.exports = __WEBPACK_EXTERNAL_MODULE_graphql_subscriptions__;","module.exports = require(\"http\");","module.exports = __WEBPACK_EXTERNAL_MODULE_image_size__;","module.exports = __WEBPACK_EXTERNAL_MODULE_jsonwebtoken__;","module.exports = __WEBPACK_EXTERNAL_MODULE_merge_graphql_schemas__;","module.exports = __WEBPACK_EXTERNAL_MODULE_mkdirp__;","module.exports = __WEBPACK_EXTERNAL_MODULE_path__;","module.exports = __WEBPACK_EXTERNAL_MODULE_progress_stream__;","module.exports = __WEBPACK_EXTERNAL_MODULE_rimraf__;","module.exports = __WEBPACK_EXTERNAL_MODULE_sequelize__;","module.exports = __WEBPACK_EXTERNAL_MODULE_sharp__;"],"sourceRoot":""}